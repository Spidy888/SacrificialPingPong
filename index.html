<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Sacrificial Ping Pong</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Press Start 2P', cursive; color:#fff; margin:0; user-select:none; background:#07111a; }
        #stars-background { position:fixed; inset:0; z-index:-1; background:#07111a; overflow:hidden; }
        .page-wrapper { display:flex; justify-content:center; align-items:center; width:100vw; min-height:100vh; box-sizing:border-box; text-align:center; }
        .homepage-title { font-size: clamp(2.5rem, 8vw, 5rem); color:#00ffff; text-shadow:0 0 10px #00ffff; }
        .menu-box { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.85); padding:1.8rem; border-radius:12px; border:2px solid #00ffff; box-shadow:0 0 20px rgba(0,255,255,0.15); width:90%; max-width:540px; }
        canvas { display:block; border-radius:12px; box-shadow: 0 0 30px rgba(0,255,255,0.12); background:transparent; }
        .score-board { position:absolute; inset:0; pointer-events:none; }
        #scoreTop, #scoreBottom { position:absolute; font-size:3rem; }
        #scoreTop { left:1.5rem; top:45%; color:rgba(255,71,87,0.5); }
        #scoreBottom { right:1.5rem; top:45%; color:rgba(0,255,255,0.45); }
        button { font-family:'Press Start 2P', cursive; background:#00ffff; color:#111; border:none; padding:0.8rem 1.2rem; border-radius:6px; cursor:pointer; margin:0.3rem; }
        .settings-row{ display:flex; gap:8px; align-items:center; justify-content:center; margin-bottom:8px; }
        @media (max-width:768px){ .menu-box{ padding:1rem; } button{ padding:0.6rem 0.8rem; } }
    </style>
</head>
<body>
<div id="stars-background"></div>

<div id="homepage-container" class="page-wrapper">
    <div>
        <h1 class="homepage-title">Sacrificial Ping Pong</h1>
        <p style="opacity:0.85">Choose your battle.</p>
        <div style="margin:1rem 0;">
            <button id="vsAiButton">Player vs AI</button>
            <button id="vsPlayerButton">Player vs Player</button>
        </div>
        <div style="max-width:760px; margin:0 auto; text-align:left; padding:1rem;">
            <h3>Controls</h3>
            <p>P1: ← → or A / D. P2: A / D (multiplayer). Touch: drag on your side.</p>
            <h3>How to Play VS AI</h3>
            <p>AI is aggressive — it predicts the ball and becomes harder as you fall behind. When you lose points your "rage" grows and your controls become jittery.</p>
        </div>
    </div>
</div>

<div id="game-wrapper" class="page-wrapper" style="display:none;">
    <div class="game-container" style="position:relative;">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="scoreBoard" class="score-board">
            <span id="scoreTop">0</span>
            <span id="scoreBottom">0</span>
        </div>

        <div id="message-box" class="menu-box">
            <h2 id="menuTitle">Sacrificial Ping Pong</h2>
            <p id="gameDescription">First to 10 wins! Both paddles split on hit.</p>
            <div style="text-align:center; margin-top:0.8rem;">
                <button id="startButton">Start Game</button>
                <button id="settingsButton">Settings</button>
                <button id="homeButton">Home</button>
            </div>
        </div>

        <div id="settings-box" class="menu-box" style="display:none;">
            <h3>Settings</h3>
            <div class="settings-row"><label>Winning Score</label><input id="winningScoreInput" type="range" min="1" max="20" value="10"><span id="winningScoreValue">10</span></div>
            <div class="settings-row" id="ai-settings-row"><label>AI Difficulty</label><input id="aiDifficultyInput" type="range" min="1" max="10" value="9"><span id="aiDifficultyValue">9</span></div>
            <div class="settings-row"><label>Ball Speed</label><input id="ballSpeedInput" type="range" min="1" max="10" value="4"><span id="ballSpeedValue">4</span></div>
            <div style="text-align:center;"><button id="saveSettingsButton">Back</button></div>
        </div>
    </div>
</div>

<script>
/* Full working index.html script
   - Predictive, very strong AI
   - Player "rage" mechanic: builds when you concede points -> jittery/inverted controls + screen shake
*/

// DOM
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const homepageContainer = document.getElementById('homepage-container');
const gameWrapper = document.getElementById('game-wrapper');
const messageBox = document.getElementById('message-box');
const settingsBox = document.getElementById('settings-box');
const startButton = document.getElementById('startButton');
const settingsButton = document.getElementById('settingsButton');
const saveSettingsButton = document.getElementById('saveSettingsButton');
const homeButton = document.getElementById('homeButton');
const vsAiButton = document.getElementById('vsAiButton');
const vsPlayerButton = document.getElementById('vsPlayerButton');

const scoreTopEl = document.getElementById('scoreTop');
const scoreBottomEl = document.getElementById('scoreBottom');
const winningScoreInput = document.getElementById('winningScoreInput');
const winningScoreValue = document.getElementById('winningScoreValue');
const aiDifficultyInput = document.getElementById('aiDifficultyInput');
const aiDifficultyValue = document.getElementById('aiDifficultyValue');
const ballSpeedInput = document.getElementById('ballSpeedInput');
const ballSpeedValue = document.getElementById('ballSpeedValue');

let gameMode = 'ai'; // 'ai' or 'multiplayer'
let animationFrameId;
let isGameOver = false;
let isCountdownActive = false;
let countdownValue = 3;

// Game constants
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;
let winningScore = parseInt(winningScoreInput.value, 10) || 10;

// Stars
const gameStars = [];
const NUM_GAME_STARS = 120;

// Synth (optional)
const synth = typeof Tone !== 'undefined' ? new Tone.Synth().toDestination() : null;

// Power-ups
const POWER_UP_CHANCE = 0.15;
const powerUps = [];
const POWER_UP_TYPES = {
    EXPAND_SELF: { id: 'EXPAND_SELF', color:'#2ecc71', duration:10000 },
    SHRINK_OPPONENT: { id:'SHRINK_OPPONENT', color:'#e74c3c', duration:7000 },
    SPEED_BOOST: { id:'SPEED_BOOST', color:'#f1c40f', duration:8000 }
};

// Game objects
const ball = { x: GAME_WIDTH/2, y: GAME_HEIGHT/2, radius:12, speed:4, baseSpeed:4, maxSpeed:20, dx:0, dy:0, activeSpeedBoost:null, speedBoostTimeoutId:null };

const player1 = { name:'Player 1', x: (GAME_WIDTH-150)/2, y: GAME_HEIGHT-30, width:150, originalWidth:150, height:20, color:'#00ffff', score:0, layer1_segments:[], layer2_segments:[], hitTimer:0, activeEffect:null, effectTimeoutId:null};
const player2 = { name:'Player 2', x: (GAME_WIDTH-150)/2, y: 10, width:150, originalWidth:150, height:20, color:'#ff4757', score:0, layer1_segments:[], layer2_segments:[], hitTimer:0, activeEffect:null, effectTimeoutId:null };

// Powerful AI (predictive)
const ai = {
    name: 'AI', x:(GAME_WIDTH-180)/2, y:10, width:180, originalWidth:180, height:20, color:'#ff4757', score:0,
    layer1_segments:[], layer2_segments:[], hitTimer:0, activeEffect:null, effectTimeoutId:null,
    initialError:0.02, error:0.02, minError:0.0, reaction:2.0, maxMoveSpeed:22
};

// Controls
const controls = { p1Left:false, p1Right:false, p2Left:false, p2Right:false };

// Player Rage system
let playerRage = 0; // 0..100
const RAGE_INCREMENT_ON_POINT_LOST = 20; // how much rage increases when player concedes
const RAGE_DECAY_PER_SECOND = 4;
const RAGE_CONTROL_JITTER_SCALE = 0.65;
const RAGE_INVERT_CHANCE = 0.14;
const RAGE_SCREENSHAKE_THRESHOLD = 35;

// UI handlers
vsAiButton.addEventListener('click', ()=> { gameMode='ai'; aiSettingsRowVisible(true); openGame(); });
vsPlayerButton.addEventListener('click', ()=> { gameMode='multiplayer'; aiSettingsRowVisible(false); openGame(); });
startButton.addEventListener('click', ()=> { init(); });
settingsButton.addEventListener('click', ()=> { messageBox.style.display='none'; settingsBox.style.display='block'; });
saveSettingsButton.addEventListener('click', ()=> { settingsBox.style.display='none'; messageBox.style.display='block'; winningScore = parseInt(winningScoreInput.value,10); winningScoreValue.textContent = winningScore; aiDifficultyValue.textContent = aiDifficultyInput.value; ballSpeedValue.textContent = ballSpeedInput.value; ai.initialError = mapRange(parseInt(aiDifficultyInput.value,10), 1, 10, 0.25, 0.01); ai.error = ai.initialError; ball.baseSpeed = mapRange(parseInt(ballSpeedInput.value,10),1,10,2,8); });
homeButton.addEventListener('click', ()=> { closeGame(); });
winningScoreInput.addEventListener('input', ()=> { winningScoreValue.textContent = winningScoreInput.value; });
aiDifficultyInput.addEventListener('input', ()=> { aiDifficultyValue.textContent = aiDifficultyInput.value; });
ballSpeedInput.addEventListener('input', ()=> { ballSpeedValue.textContent = ballSpeedInput.value; });

// Helper to show/hide AI settings
function aiSettingsRowVisible(show){
    const row = document.getElementById('ai-settings-row');
    if(row) row.style.display = show ? 'flex' : 'none';
}

// Open game UI
function openGame(){
    homepageContainer.style.display = 'none';
    gameWrapper.style.display = 'flex';
    messageBox.style.display = 'block';
    settingsBox.style.display = 'none';
    messageBox.querySelector('h2').innerText = 'Sacrificial Ping Pong';
    messageBox.querySelector('p').innerText = `First to ${winningScore} wins! AI will be ruthless.`;
    resizeCanvas();
}

// Close game and return home
function closeGame(){
    homepageContainer.style.display = 'flex';
    gameWrapper.style.display = 'none';
    cancelAnimationFrame(animationFrameId);
}

// Map utility
function mapRange(v, a1, b1, a2, b2){ return a2 + (v-a1)*(b2-a2)/(b1-a1); }

// Input handling
document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if(gameMode === 'multiplayer'){
        if(key === 'arrowleft' || key === 'left') controls.p1Left = true;
        if(key === 'arrowright' || key === 'right') controls.p1Right = true;
        if(key === 'a') controls.p2Left = true;
        if(key === 'd') controls.p2Right = true;
    } else {
        if(key === 'arrowleft' || key === 'left' || key === 'a') controls.p1Left = true;
        if(key === 'arrowright' || key === 'right' || key === 'd') controls.p1Right = true;
    }
});
document.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    if(gameMode === 'multiplayer'){
        if(key === 'arrowleft' || key === 'left') controls.p1Left = false;
        if(key === 'arrowright' || key === 'right') controls.p1Right = false;
        if(key === 'a') controls.p2Left = false;
        if(key === 'd') controls.p2Right = false;
    } else {
        if(key === 'arrowleft' || key === 'left' || key === 'a') controls.p1Left = false;
        if(key === 'arrowright' || key === 'right' || key === 'd') controls.p1Right = false;
    }
});

// Touch controls (simple dragging)
function handleTouchMove(e){
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const scaleX = GAME_WIDTH / rect.width;
    for(let i=0;i<e.touches.length;i++){
        const t = e.touches[i];
        const x = (t.clientX - rect.left) * scaleX;
        const y = (t.clientY - rect.top) * (GAME_HEIGHT/rect.height);
        if(t.clientY - rect.top > rect.height/2){ // bottom half -> player1
            player1.x = x - player1.width/2;
            player1.x = Math.max(0, Math.min(GAME_WIDTH - player1.width, player1.x));
        } else if(gameMode === 'multiplayer'){ // top half -> player2
            player2.x = x - player2.width/2;
            player2.x = Math.max(0, Math.min(GAME_WIDTH - player2.width, player2.x));
        }
    }
}
canvas.addEventListener('touchmove', handleTouchMove, { passive:false });
canvas.addEventListener('touchstart', handleTouchMove, { passive:false });

// Resize canvas to viewport while keeping game coordinate system
function resizeCanvas(){
    const aspect = GAME_WIDTH / GAME_HEIGHT;
    let w = window.innerWidth - 20;
    let h = window.innerHeight - 20;
    if(h * aspect > w) h = w / aspect; else w = h * aspect;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
    draw(); // draw once
}
window.addEventListener('resize', resizeCanvas);

// Stars background
function createGameStars(){
    gameStars.length = 0;
    for(let i=0;i<NUM_GAME_STARS;i++){
        gameStars.push({ x: Math.random()*GAME_WIDTH, y: Math.random()*GAME_HEIGHT, size: Math.random()*2+0.4, speed: Math.random()*0.6+0.1 });
    }
}

// Reset paddle segments helper
function resetPaddleSegments(p){
    p.layer1_segments = [{ x_offset:0, width: p.width }];
    p.layer2_segments = [{ x_offset:0, width: p.width }];
}

// Reset paddles & effects
function resetPaddles(){
    powerUps.length = 0;
    [player1, player2, ai].forEach(p=>{
        clearActiveEffect(p);
        p.width = p.originalWidth;
        p.x = (GAME_WIDTH - p.width)/2;
        p.score = 0;
        resetPaddleSegments(p);
    });
    ai.error = ai.initialError;
    playerRage = 0;
}

// Launch ball with slight randomness
function launchBall(){
    ball.speed = ball.baseSpeed;
    const angle = (Math.random()*Math.PI/2) - Math.PI/4;
    ball.dx = ball.speed * Math.sin(angle);
    ball.dy = ball.speed * (Math.random()>0.5 ? 1 : -1) * Math.cos(angle);
}

// Reset ball to center stationary
function resetBall(){
    ball.speed = ball.baseSpeed;
    ball.x = GAME_WIDTH/2;
    ball.y = GAME_HEIGHT/2;
    ball.dx = 0; ball.dy = 0;
}

// Countdown before serve
function startInitialCountdown(){
    isCountdownActive = true;
    countdownValue = 3;
    resetBall();
    const id = setInterval(()=>{
        if(synth) synth.triggerAttackRelease("G4","16n");
        countdownValue--;
        if(countdownValue <= 0){
            clearInterval(id);
            isCountdownActive = false;
            if(synth) synth.triggerAttackRelease("C5","8n");
            launchBall();
        }
    },1000);
}

// Initialization and start game loop
function init(){
    isGameOver = false;
    if(ball.speedBoostTimeoutId) clearTimeout(ball.speedBoostTimeoutId);
    ball.activeSpeedBoost = null;
    createGameStars();
    resetPaddles();
    updateScores();
    messageBox.style.display = 'none';
    settingsBox.style.display = 'none';
    startInitialCountdown();
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    gameLoop();
}

// Update scoreboard display
function updateScores(scorer){
    scoreBottomEl.textContent = player1.score;
    scoreTopEl.textContent = (gameMode==='ai') ? ai.score : player2.score;
    const el = (scorer === player1) ? scoreBottomEl : scoreTopEl;
    if(el){
        el.classList.add('score-pop');
        setTimeout(()=> el.classList.remove('score-pop'), 420);
    }
}

// Prediction: simulate ball to AI y and return predicted X
function predictBallTargetX(){
    let simX = ball.x, simY = ball.y, simDX = ball.dx, simDY = ball.dy;
    const r = ball.radius;
    const maxSteps = 2000;
    for(let i=0;i<maxSteps;i++){
        simX += simDX;
        simY += simDY;
        if(simX + r > GAME_WIDTH){ simX = GAME_WIDTH - r; simDX *= -1; }
        else if(simX - r < 0){ simX = r; simDX *= -1; }
        if(simDY < 0 && simY - r <= ai.y + ai.height){ return Math.max(0, Math.min(GAME_WIDTH, simX)); }
        if(Math.abs(simDX) > 500 || Math.abs(simDY) > 500) break;
    }
    return ball.x;
}

// Movement handling: player with rage effects, AI predictive movement
function movePaddles(){
    // Rage decay over time
    if(playerRage > 0) playerRage = Math.max(0, playerRage - (RAGE_DECAY_PER_SECOND * (1/60)));

    // Player base speed reduced when raging
    const baseSpeed = 7;
    const rageFactor = 1 - (Math.min(100, playerRage)/100)*0.55; // up to ~55% slow down
    const paddleSpeed = Math.max(3, baseSpeed * rageFactor);

    // Player 1 movement with jitter and possible inversion
    let move = 0;
    if(controls.p1Left) move -= paddleSpeed;
    if(controls.p1Right) move += paddleSpeed;

    if(playerRage > 10){
        const jitter = (Math.random() - 0.5) * (playerRage/100) * RAGE_CONTROL_JITTER_SCALE * paddleSpeed;
        move += jitter;
    }
    if(playerRage > 60 && Math.random() < (RAGE_INVERT_CHANCE * (playerRage/100))){
        move = -move;
    }
    player1.x += move;
    player1.x = Math.max(0, Math.min(GAME_WIDTH - player1.width, player1.x));

    // Multiplayer second player keyboard control
    if(gameMode === 'multiplayer'){
        if(controls.p2Left && player2.x > 0) player2.x -= paddleSpeed;
        if(controls.p2Right && player2.x < GAME_WIDTH - player2.width) player2.x += paddleSpeed;
    } else {
        // AI movement: predictive intercept + adaptive error & reaction
        const predictedX = predictBallTargetX();
        const paddleCenter = ai.x + ai.width/2;
        const distance = predictedX - paddleCenter;

        // AI move calculation favoring stronger reaction when ahead or when difficulty is high
        let aiMove = distance * 0.2 * ai.reaction + Math.sign(distance) * (ball.speed * 0.8);
        // small noise from ai.error
        aiMove += (Math.random()-0.5) * ball.speed * ai.error * 0.6;
        aiMove = Math.max(-ai.maxMoveSpeed, Math.min(ai.maxMoveSpeed, aiMove));
        ai.x += aiMove;
        ai.x = Math.max(0, Math.min(GAME_WIDTH - ai.width, ai.x));

        // adjust AI difficulty dynamically by score difference
        const diff = ai.score - player1.score;
        const clampDiff = Math.max(-5, Math.min(10, diff));
        ai.error = Math.max(ai.minError, ai.initialError - (clampDiff * 0.01));
        ai.reaction = 2.0 + Math.max(0, clampDiff) * 0.12;
        ai.maxMoveSpeed = 22 + Math.max(0, clampDiff) * 2;
    }
}

// Ball movement, collisions, scoring
function moveBall(){
    ball.x += ball.dx;
    ball.y += ball.dy;

    // Side wall bounce
    if(ball.x + ball.radius > GAME_WIDTH || ball.x - ball.radius < 0){
        ball.dx *= -1;
        if(synth) synth.triggerAttackRelease("G3","8n");
    }

    // Score check
    let pointScored = false;
    if(ball.y > GAME_HEIGHT){
        // Top player scores
        if(!isGameOver){
            if(gameMode === 'ai'){
                ai.score++;
                // increase player rage strongly when AI scores
                playerRage = Math.min(100, playerRage + RAGE_INCREMENT_ON_POINT_LOST);
                ai.reaction = Math.min(4.0, ai.reaction + 0.08);
            } else {
                player2.score++;
            }
            updateScores((gameMode === 'ai') ? ai : player2);
        }
        pointScored = true;
    } else if(ball.y < 0){
        if(!isGameOver){
            player1.score++;
            updateScores(player1);
            if(gameMode === 'ai'){
                // reward player scoring by slightly lowering AI error
                ai.error = Math.max(ai.minError, ai.initialError - (player1.score / winningScore) * (ai.initialError - ai.minError));
            }
        }
        pointScored = true;
    }

    if(pointScored){
        const winner = checkWinner();
        if(winner){
            endGame(`${winner.name} Wins!`);
        } else {
            // reset paddle segments but keep powerup widths in place
            resetPaddleSegments(player1);
            const topPaddle = (gameMode === 'ai') ? ai : player2;
            resetPaddleSegments(topPaddle);
            resetBall();
            launchBall();
        }
        return;
    }

    // Paddle collisions (bottom player1)
    const topPaddle = (gameMode === 'ai') ? ai : player2;
    if(ball.dy > 0 && ball.y + ball.radius >= player1.y && ball.y + ball.radius <= player1.y + player1.height){
        handlePaddleCollision(player1);
    }
    if(ball.dy < 0 && ball.y - ball.radius <= topPaddle.y + topPaddle.height && ball.y - ball.radius >= topPaddle.y){
        handlePaddleCollision(topPaddle);
    }
}

// Handle paddle collision with two-layer paddle segmentation
function handlePaddleCollision(paddle){
    for(let i=0;i<paddle.layer1_segments.length;i++){
        const seg = paddle.layer1_segments[i];
        if(ball.x > paddle.x + seg.x_offset && ball.x < paddle.x + seg.x_offset + seg.width){
            splitSegment(paddle, paddle.layer1_segments, i);
            return;
        }
    }
    for(let i=0;i<paddle.layer2_segments.length;i++){
        const seg = paddle.layer2_segments[i];
        if(ball.x > paddle.x + seg.x_offset && ball.x < paddle.x + seg.x_offset + seg.width){
            splitSegment(paddle, paddle.layer2_segments, i);
            return;
        }
    }
}

// Split a segment and apply ball physics
function splitSegment(paddle, layer, index){
    if(synth) synth.triggerAttackRelease("C4","8n");
    paddle.hitTimer = 8;

    const hitSegment = layer[index];
    const splitPoint = ball.x - paddle.x;
    const gapWidth = ball.radius * 2;
    const newLeftWidth = splitPoint - gapWidth/2 - hitSegment.x_offset;
    const newRightX = splitPoint + gapWidth/2;
    const newRightWidth = (hitSegment.x_offset + hitSegment.width) - newRightX;

    layer.splice(index, 1);
    if(newLeftWidth > ball.radius) layer.push({ x_offset: hitSegment.x_offset, width: newLeftWidth });
    if(newRightWidth > ball.radius) layer.push({ x_offset: newRightX, width: newRightWidth });

    // ball reaction
    const collidePoint = (ball.x - (paddle.x + paddle.width/2)) / (paddle.width/2);
    const angleRad = collidePoint * (Math.PI/4);
    const direction = (paddle === player1) ? -1 : 1;
    // slightly increase speed but clamp
    ball.speed = Math.min(ball.maxSpeed, ball.speed * 1.035);
    ball.dx = ball.speed * Math.sin(angleRad);
    ball.dy = direction * ball.speed * Math.cos(angleRad);

    // speed boost multiplier if active
    if(ball.activeSpeedBoost){
        const topP = (gameMode === 'ai') ? ai : player2;
        const isHeadingToOpp = (ball.activeSpeedBoost === player1 && ball.dy < 0) || (ball.activeSpeedBoost === topP && ball.dy > 0);
        if(isHeadingToOpp){ ball.dx *= 1.45; ball.dy *= 1.45; }
    }

    // possibly spawn power-up
    if(Math.random() < POWER_UP_CHANCE) spawnPowerUp(paddle);
}

// Spawn a power-up near the ball that travels toward opposite side
function spawnPowerUp(spawningPaddle){
    const keys = Object.keys(POWER_UP_TYPES);
    const type = POWER_UP_TYPES[keys[Math.floor(Math.random()*keys.length)]];
    powerUps.push({ x: ball.x, y: ball.y, size:16, type: type, dy: (spawningPaddle === player1) ? -2 : 2 });
}

// Move power-ups, check collections
function moveAndCheckPowerUps(){
    for(let i=powerUps.length-1;i>=0;i--){
        const p = powerUps[i];
        p.y += p.dy;
        const topP = (gameMode==='ai') ? ai : player2;
        let collector = null;
        if(p.dy < 0 && p.y - p.size < topP.y + topP.height && p.y + p.size > topP.y){
            if(p.x > topP.x && p.x < topP.x + topP.width) collector = topP;
        } else if(p.dy > 0 && p.y + p.size > player1.y && p.y - p.size < player1.y + player1.height){
            if(p.x > player1.x && p.x < player1.x + player1.width) collector = player1;
        }
        if(collector){
            applyPowerUp(collector, p);
            powerUps.splice(i,1);
            if(synth) synth.triggerAttackRelease("E5","8n");
        } else if(p.y < -p.size || p.y > GAME_HEIGHT + p.size){
            powerUps.splice(i,1);
        }
    }
}

function applyPowerUp(paddle, powerUp){
    const topP = (gameMode==='ai') ? ai : player2;
    const opponent = (paddle === player1) ? topP : player1;
    clearActiveEffect(paddle);
    if(powerUp.type.id === 'SHRINK_OPPONENT') clearActiveEffect(opponent);

    switch(powerUp.type.id){
        case 'EXPAND_SELF':
            paddle.width = GAME_WIDTH;
            paddle.x = 0;
            resetPaddleSegments(paddle);
            paddle.activeEffect = powerUp.type;
            paddle.effectTimeoutId = setTimeout(()=> clearActiveEffect(paddle), powerUp.type.duration);
            break;
        case 'SHRINK_OPPONENT':
            opponent.width = opponent.originalWidth * 0.45;
            opponent.x = Math.min(opponent.x, GAME_WIDTH - opponent.width);
            resetPaddleSegments(opponent);
            opponent.activeEffect = powerUp.type;
            opponent.effectTimeoutId = setTimeout(()=> clearActiveEffect(opponent), powerUp.type.duration);
            break;
        case 'SPEED_BOOST':
            if(ball.speedBoostTimeoutId) clearTimeout(ball.speedBoostTimeoutId);
            ball.activeSpeedBoost = paddle;
            ball.speedBoostTimeoutId = setTimeout(()=> { ball.activeSpeedBoost = null; }, powerUp.type.duration);
            break;
    }
}

function clearActiveEffect(paddle){
    if(paddle.effectTimeoutId) clearTimeout(paddle.effectTimeoutId);
    paddle.width = paddle.originalWidth;
    paddle.activeEffect = null;
    paddle.effectTimeoutId = null;
    resetPaddleSegments(paddle);
}

// Check for winner
function checkWinner(){
    if(player1.score >= winningScore) return player1;
    const topScore = (gameMode==='ai') ? ai.score : player2.score;
    if(topScore >= winningScore) return (gameMode==='ai') ? ai : player2;
    return null;
}

function endGame(message){
    isGameOver = true;
    cancelAnimationFrame(animationFrameId);
    messageBox.style.display = 'block';
    messageBox.querySelector('h2').innerText = message;
    messageBox.querySelector('p').innerText = `Final Score -> P1: ${player1.score} | ${gameMode==='ai' ? 'AI' : 'P2'}: ${gameMode==='ai' ? ai.score : player2.score}`;
    startButton.innerText = 'Play Again';
    settingsButton.style.display = 'inline-block';
    homeButton.style.display = 'inline-block';
}

// Drawing functions
function moveAndDrawGameStars(){
    ctx.fillStyle = '#07111a';
    ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    for(const s of gameStars){
        s.y += s.speed;
        if(s.y > GAME_HEIGHT){ s.y = 0; s.x = Math.random()*GAME_WIDTH; }
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
        ctx.fill();
    }
}

function drawNet(){
    const squareSize = 8, gap = 12, total = squareSize + gap;
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    for(let i=0;i<Math.ceil(GAME_WIDTH/total);i++){
        const x = i*total + gap/2;
        const y = GAME_HEIGHT/2 - squareSize/2;
        ctx.fillRect(x,y,squareSize,squareSize);
    }
}

function drawBall(){
    ctx.save();
    if(ball.activeSpeedBoost){
        ctx.shadowColor = POWER_UP_TYPES.SPEED_BOOST.color;
        ctx.shadowBlur = 18;
    }
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2); ctx.fill();
    ctx.restore();
}

function drawPaddle(p){
    const LAYER_OFFSET = 4;
    const isBottom = p.y > GAME_HEIGHT/2;
    const mainColor = p.hitTimer > 0 ? '#fff' : p.color;
    const secondColor = (p.color === '#00ffff') ? '#008b8b' : '#b22222';
    const yOffset = isBottom ? -LAYER_OFFSET : LAYER_OFFSET;
    // back layer
    ctx.fillStyle = secondColor;
    for(const seg of p.layer2_segments){
        ctx.fillRect(p.x + seg.x_offset, p.y + yOffset, seg.width, p.height);
    }
    // front layer
    ctx.fillStyle = mainColor;
    for(const seg of p.layer1_segments){
        ctx.fillRect(p.x + seg.x_offset, p.y, seg.width, p.height);
    }
}

function drawPowerUps(){
    for(const pu of powerUps){
        ctx.fillStyle = pu.type.color;
        ctx.beginPath();
        ctx.arc(pu.x, pu.y, pu.size, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.font = '10px "Press Start 2P"';
    }
}

// Main draw
function draw(){
    // screen shake if playerRage high
    const shouldShake = playerRage > RAGE_SCREENSHAKE_THRESHOLD;
    if(shouldShake){
        const intensity = (playerRage - RAGE_SCREENSHAKE_THRESHOLD) / (100 - RAGE_SCREENSHAKE_THRESHOLD);
        const maxShake = 6;
        const sx = (Math.random()-0.5) * maxShake * intensity;
        const sy = (Math.random()-0.5) * maxShake * intensity;
        ctx.save();
        ctx.translate(sx, sy);
    }

    moveAndDrawGameStars();
    drawNet();
    drawBall();
    drawPaddle(player1);
    drawPaddle((gameMode==='ai') ? ai : player2);
    drawPowerUps();

    // Countdown number
    if(isCountdownActive){
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.font = '80px "Press Start 2P"';
        ctx.textAlign = 'center'; ctx.textBaseline='middle';
        ctx.fillText(countdownValue, GAME_WIDTH/2, GAME_HEIGHT/2);
    }

    if(shouldShake) ctx.restore();
}

// Game loop
function gameLoop(){
    // update timers
    [player1, player2, ai].forEach(p => { if(p.hitTimer > 0) p.hitTimer--; });
    // move + physics only when not in countdown and not game over
    if(!isCountdownActive && !isGameOver){
        movePaddles();
        moveBall();
        moveAndCheckPowerUps();
    }
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
}

// Paddle collision splitting already plays sound etc.

// Power-ups and other functions above included

// Utilities: trigger start/end from controls
function startFromMenu(){
    init();
}

// Setup initial state
(function startup(){
    // initialize UI defaults and event wiring
    resizeCanvas();
    createGameStars();
    resetPaddles();
    // map UI difficulty slider to ai.initialError: higher slider -> lower error (harder)
    ai.initialError = mapRange(parseInt(aiDifficultyInput.value,10), 1, 10, 0.25, 0.01);
    ai.error = ai.initialError;
    ball.baseSpeed = mapRange(parseInt(ballSpeedInput.value,10),1,10,2,8);
    winningScore = parseInt(winningScoreInput.value,10) || 10;
    winningScoreValue.textContent = winningScoreInput.value;
    aiDifficultyValue.textContent = aiDifficultyInput.value;
    ballSpeedValue.textContent = ballSpeedInput.value;

    // wire start button to either start or restart
    startButton.addEventListener('click', ()=>{
        init();
    });

    // ensure settings/back/home show/hide
    settingsBox.style.display = 'none';
    messageBox.style.display = 'block';
})();

// small helper to ensure UI references exist
const aiSettingsRow = document.getElementById('ai-settings-row');
</script>
</body>
</html>
